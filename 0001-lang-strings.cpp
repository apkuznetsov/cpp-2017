/*
  Вариант 13.
  Ввести с клавиатуры символьную строку длиной не более 80 символов,
  рассматриваемую как произвольное абстрактное предложение, состоящее из слов.
  Слова отделяются друг от друга как минимум одним символом пробела.
  Строка должна быть введена посимвольно с использованием функции getchar().
  Каждому символу ставится в соответствие код, подобный азбуке Морзе.
  Построить новую строку, в которой содержится перевод исходной строки в кодированный текст.
*/

#include "stdafx.h"
#include <stdio.h>
#include <locale.h>  
#include <windows.h>

#define LEN 80	// длина массива

void getString(char str[]) {
	/*	т. к. по условию ёмкость не более LEN, то максимальное число символов в строке -- (LEN - 1),
		последним -- всегда должен быть '\0';
		таким образом, нужно проверить выход за пределы массива,
		в данной реализации, символы введённые после (LEN - 1) игнорируются -- не записываются в строку	*/
	int i = -1;
	do {
		if (i == (LEN - 1))
			break;
		++i;
	} while ((str[i] = (char)getchar()) != '\n');
	str[i] = '\0';
}

void convertString(char strOld[], char strNew[])
{
	char* token;	// лексема
	token = strtok(strOld, " ");

	while (token != NULL)
	{
		for (int i = 0; i < strlen(token); i++)
		{
			switch (token[i]) {
			case 'a':
				strcat(strNew, ".-");
				break;
			case 's':
				strcat(strNew, "...");
				break;
			case 'd':
				strcat(strNew, "-..");
				break;
			case 'f':
				strcat(strNew, "..-.");
				break;
			case 'g':
				strcat(strNew, "-..");
				break;
			default:
				strcat(strNew, "*");
				break;
			}
		}
		strcat(strNew, " ");
		token = strtok(NULL, " ");
	}
}

void main() {
	setlocale(LC_ALL, "RUS");

	puts("Лабораторная работа № 1. Основы языка С++. Язык С. Обработка строк.\nВариант № 13. Выполнил: Андрей Кузнецов, группа 6213.");
	puts("");

	char strEntered[LEN];								// строка
	char strConverted[(LEN - 1) * 5 + 1] = { '\0' };	// преобразованная строка
														/*	"- 1" -- так как один элемент массива отводиться под '\0',
															"* 5" -- максимальный код символа в азбуке Морзе  -- 5,
															"+ 1" -- чтобы записать '\0'	*/

	puts("Введите строку:");
	getString(strEntered);
	convertString(strEntered, strConverted);
	puts("");

	puts("Закодированная введённая строка:");
	puts(strConverted);

	puts("");
	system("pause");
}

/*
	int puts( const char * string );
Функция puts выводит строку типа char*, на которую указывает параметр string
в стандартный поток вывод и добавляет символ новой строки 'n'. Функция
начинает копировать строку с адреса, указанного в string, пока не достигнет
нулевого символа '\0'. Этот заключительный, нулевой символ не копируется в
стандартный поток вывод.

	int getchar ( void );
Получить символ из стандартного потока ввода. Функция getchar возвращает
следующий символ из стандартного потока ввода (stdin). Эта функция
эквивалентна getc, которая принимает стандартный поток ввода в качестве
аргумента.

	char * strtok( char * string, const char * delim );
Функция strtok выполняет поиск лексем в строке string. Последовательность
вызовов этой функции разбивают строку string на лексемы, которые
представляют собой последовательности символов, разделенных символами
разделителями.
	На первый вызов, функция принимает строку string в качестве аргумента,
чей первый символ используется в качестве начальной точки для поиска лексем.
В последующие вызовы, функция ожидает нулевого указателя и использует
позицию сразу после окончания последней лексемы как новое местонахождение
для сканирования.
	Для определения начала лексемы функция сначала определяет символы,
не содержащиеся в строке delim, то есть они являются символами
разделителями. А затем посимвольно проверяет остальную часть строки до
первого символа-разделителя, который сигнализирует конец лексемы.
	Этот конечный маркер автоматически заменяется нулевым символом,
и лексема возвращается функцией. После этого, следующие вызовы функции
strtok начинаются с этого нулевого символа.

	size_t strlen( const char * string );
Длина Си-строки определяется по достижению нулевого символа  — нуль
терминатор. Функция strlen видит начало Си-строки  и начинает сначала
считать количество символов (байтов, отводимых под каждый символ), этот
процесс выполняется до тех пор, пока не будет достигнут завершающий нулевой
символ. Обратите внимание на то, что завершающий нулевой символ не входит
в длину строки. Он является служебным символом, для обозначения завершения
Си-строки.

	char * strcat( char * destptr, const char * srcptr );
Объединение строк. Функция добавляет копию строки srcptr в конец строки
destptr. Нулевой символ конца строки destptr заменяется первым символом
строки srcptr, и новый нуль-символ добавляется в конец уже новой строки,
сформированной объединением символов двух строк в строке destptr.
*/

/*void convertString(char strOld[], char strNew[])
{
	int i = 0;
	int j = 0;
	while (strOld[i] != '\0') {
		switch (strOld[i]) {
		case ' ':
			strNew[j++] = ' ';
			break;
		case 'a':
			strNew[j++] = '.';
			strNew[j++] = '-';
			break;
		case 's':
			strNew[j++] = '.';
			strNew[j++] = '.';
			strNew[j++] = '.';
			break;
		case 'd':
			strNew[j++] = '-';
			strNew[j++] = '.';
			strNew[j++] = '.';
			break;
		case 'f':
			strNew[j++] = '.';
			strNew[j++] = '.';
			strNew[j++] = '-';
			strNew[j++] = '.';
			break;
		case 'g':
			strNew[j++] = '-';
			strNew[j++] = '.';
			strNew[j++] = '.';
			break;
		default:
			strNew[j++] = '*';
			break;
		}
		++i;
	}
	strNew[j] = '\0';
}*/